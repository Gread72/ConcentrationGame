package com.gread.games.concentration.model {	/*		Class GameModel		Main model for game	*/	import com.gread.games.concentration.model.vo.GameCardVO;		import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.net.SharedObject;		import org.osflash.signals.Signal;
		public class GameModel {				/* Private and Public variables */		public var numColumns:Number = 4;		public var numRows:Number = 3;		public var numOfCards:Number = numColumns * numRows;		public var gameSelectionsTotal:Number = numOfCards/2; //6		public var cardSeries:Vector.<GameCardVO> = new Vector.<GameCardVO>();		public var currentGameStatus:Signal =  new Signal();		public var resetGame:Signal = new Signal();				static public var COLOR_GREEN:uint = 0x00FF00;		static public var COLOR_RED:uint = 0xFF0000;		static public var COLOR_BLUE:uint = 0x0000FF;		static public var COLOR_BLUE_GREEN:uint = 0x00FFFF;		static public var COLOR_RED_GREEN:uint = 0xFFFF00;		static public var COLOR_RED_BLUE:uint = 0xFF00FF;				private var _choices:Array = new Array();		private var _numOfCorrect:Number = 0;		private var _timeOfGame:Number = 0;		private var _isGameOver:Boolean = false;		private var _bestTime:Number = 0;		private var so:SharedObject;				/* constructor function */		public function GameModel() {						so = SharedObject.getLocal("ConcentrationGame");			if(so.data.bestTime){				_bestTime = so.data.bestTime;			}else{				load();			}					}				/*			function compareCardsSelected			Logic to match selected cards - compare cards			@param firstCard GameCardVO			@param secondCard GameCardVO			@return boolean		*/		public function get bestTime():Number
		{			return _bestTime;
		}		public function set bestTime(value:Number):void
		{
			_bestTime = value;						so = SharedObject.getLocal("ConcentrationGame");						if(so.data.bestTime){				so.data.bestTime = _bestTime;				so.flush();			}else{				save();			}						
		}		public function compareCardsSelected(firstCard:GameCardVO, secondCard:GameCardVO):Boolean{			// return True or False whether cards are correct / the same id/type			var matchedCards:Boolean = false;						if(firstCard.id == secondCard.id){				// Increase the correct num of selected card pair				matchedCards = true;				_numOfCorrect++;				trace("numOfCorrect :" + _numOfCorrect);								if(gameSelectionsTotal == _numOfCorrect){					trace("gameOver");					_isGameOver = true;				}			}						return matchedCards;		}				/*			function buildMemorySeries()			Build the series of memory cards			Note: should create a algorithm to randomize series dynammically 			@return void		*/		public function buildMemorySeries():void{			/*			cardSeries.push(new GameCardVO("green", GameModel.COLOR_GREEN));			cardSeries.push(new GameCardVO("green", GameModel.COLOR_GREEN));			cardSeries.push(new GameCardVO("blue", GameModel.COLOR_BLUE));			cardSeries.push(new GameCardVO("blue", GameModel.COLOR_BLUE));			cardSeries.push(new GameCardVO("red", GameModel.COLOR_RED));			cardSeries.push(new GameCardVO("red", GameModel.COLOR_RED));			cardSeries.push(new GameCardVO("bluegreen", GameModel.COLOR_BLUE_GREEN));			cardSeries.push(new GameCardVO("bluegreen", GameModel.COLOR_BLUE_GREEN));			cardSeries.push(new GameCardVO("redblue", GameModel.COLOR_RED_BLUE));			cardSeries.push(new GameCardVO("redblue", GameModel.COLOR_RED_BLUE));			cardSeries.push(new GameCardVO("redgreen", GameModel.COLOR_RED_GREEN));			cardSeries.push(new GameCardVO("redgreen", GameModel.COLOR_RED_GREEN));			*/						/*			cardSeries.push(new GameCardVO("green", GameModel.COLOR_GREEN));			cardSeries.push(new GameCardVO("redgreen", GameModel.COLOR_RED_GREEN));			cardSeries.push(new GameCardVO("bluegreen", GameModel.COLOR_BLUE_GREEN));			cardSeries.push(new GameCardVO("blue", GameModel.COLOR_BLUE));			cardSeries.push(new GameCardVO("red", GameModel.COLOR_RED));			cardSeries.push(new GameCardVO("bluegreen", GameModel.COLOR_BLUE_GREEN));			cardSeries.push(new GameCardVO("redblue", GameModel.COLOR_RED_BLUE));			cardSeries.push(new GameCardVO("green", GameModel.COLOR_GREEN));			cardSeries.push(new GameCardVO("red", GameModel.COLOR_RED));			cardSeries.push(new GameCardVO("redblue", GameModel.COLOR_RED_BLUE));			cardSeries.push(new GameCardVO("blue", GameModel.COLOR_BLUE));			cardSeries.push(new GameCardVO("redgreen", GameModel.COLOR_RED_GREEN));			*/						// reset/start game			_numOfCorrect = 0;			_timeOfGame = 0;			_isGameOver = false;			cardSeries = new Vector.<GameCardVO>();			randomizeCards();					}				private function randomizeCards():void{			_choices.push("green");			_choices.push("blue");			_choices.push("red");			_choices.push("redgreen");			_choices.push("bluegreen");			_choices.push("redblue");						for(var i:Number = 0; i < 12; i++){				cardSeries.push( createGameCard() );				//var gcVO:GameCardVO = createGameCard();			}		}				private function createGameCard():GameCardVO{			// get random value based on 1 and whatever the length of choices is.			var choicesLength:Number = _choices.length;			var rand:Number = randomRange(0, choicesLength - 1);			var textChoice:String = _choices[rand];						//choice has not been added to cardseries, if it exists remove it from choices (it as added before) 			//	Note: Should only have one color series			var cardSeriesLength:Number = cardSeries.length;			if(cardSeriesLength > 0){				for (var i:Number = 0; i < cardSeriesLength; i++){					var item:GameCardVO = cardSeries[i];					if(textChoice == item.id){						_choices.splice( _choices.indexOf(textChoice) , 1);						break;					}				}			}						var gcVO:GameCardVO;			switch(textChoice){				case "green":				gcVO = new GameCardVO("green", GameModel.COLOR_GREEN);				break;								case "blue":				gcVO = new GameCardVO("blue", GameModel.COLOR_BLUE)				break;								case "red":				gcVO = new GameCardVO("red", GameModel.COLOR_RED);				break;								case "redgreen":				gcVO = new GameCardVO("redgreen", GameModel.COLOR_RED_GREEN)				break;								case "bluegreen":				gcVO = new GameCardVO("bluegreen", GameModel.COLOR_BLUE_GREEN)				break;								case "redblue":				gcVO = new GameCardVO("redblue", GameModel.COLOR_RED_BLUE);				break;			}						return gcVO;		}				private function randomRange(minNum:Number, maxNum:Number):Number{			return (Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum);		}				public function set timeOfGame(value:Number):void{			_timeOfGame = value;			currentGameStatus.dispatch({"timeOfGame": _timeOfGame});		}				public function get timeOfGame():Number{			return _timeOfGame;		}				public function get isGameOver():Boolean{			return _isGameOver;		}				public function set isGameOver(value:Boolean):void{			_isGameOver = value;		}				///				/**		 * Get a FileStream for reading or writing the save file. 		 * @param write If true, we will write to the file. If false, we will read.		 * @param sync If true, we do synchronous writes. If false, asynchronous.		 * @return A FileStream instance we can read or write with. Don't forget to close it!		 */		private function getSaveStream(write:Boolean, sync:Boolean = true):FileStream		{			// The data file lives in the app storage directory, per iPhone guidelines. 			var f:File = File.applicationStorageDirectory.resolvePath("ConcentrationGame.dat");						if(f.exists == false)				return null;						// Try creating and opening the stream.			var fs:FileStream = new FileStream();			try			{				// If we are writing asynchronously, openAsync.				if(write && !sync)					fs.openAsync(f, FileMode.WRITE);				else				{					// For synchronous write, or all reads, open synchronously.					fs.open(f, write ? FileMode.WRITE : FileMode.READ);				}			}			catch(e:Error)			{				// On error, simply return null.				return null;			}			return fs;		}				private function load():void		{			// Get the stream and read from it.			var fs:FileStream = getSaveStream(false);			if(fs)			{				try				{					_bestTime = fs.readInt();					fs.close();				}				catch(e:Error)				{					trace("Couldn't load due to error: " + e.toString());				}			}						trace("Loaded _bestTime= " + _bestTime);		}				private function save():void		{								// Get stream and write to it – asynchronously, to avoid hitching.			var fs:FileStream = getSaveStream(true, false);			fs.writeInt(_bestTime);			fs.close();						trace("Saved _bestTime = " + _bestTime);		}							}	}